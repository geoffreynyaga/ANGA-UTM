"""
This type stub file was generated by pyright.
"""

import logging
from contextlib import contextmanager
from . import _compat as _

""" Generation core.

mixer.main
~~~~~~~~~~

The module implements objects generation.

:copyright: 2013 by Kirill Klenov.
:license: BSD, see LICENSE for more details.

"""
SKIP_VALUE = object()
LOGLEVEL = logging.WARN
LOGGER = logging.getLogger('mixer')
if not LOGGER.handlers and not LOGGER.root.handlers:
    ...
class TypeMixerMeta(type):
    """ Cache typemixers by scheme. """
    mixers = ...
    def __call__(cls, cls_type, mixer=..., factory=..., fake=...):
        ...
    


class TypeMixer(_.with_metaclass(TypeMixerMeta)):
    """ Generate objects by scheme. """
    factory = ...
    FAKE = ...
    MIX = ...
    RANDOM = ...
    SELECT = ...
    SKIP = ...
    def __init__(self, cls, mixer=..., factory=..., fake=...) -> None:
        ...
    
    def __repr__(self):
        ...
    
    def blend(self, **values):
        """ Generate object.

        :param **values: Predefined fields
        :return value: a generated value

        """
        ...
    
    def postprocess(self, target, postprocess_values):
        """ Run the code after a generation. """
        ...
    
    def populate_target(self, values):
        """ Populate a target by values. """
        ...
    
    def get_value(self, name, value):
        """ Prepare value for field with name.

        :return : (name, value) or None

        """
        ...
    
    def gen_field(self, field):
        """ Generate value by field.

        :param field: Instance of :class:`Field`

        :return : None or (name, value) for later usage

        """
        ...
    
    def gen_random(self, field_name, random):
        """ Generate a random value for field with `field_name`.

        :param field_name: Name of field for generation.
        :param random: Instance of :class:`~mixer.main.Random`.

        :return : None or (name, value) for later use

        """
        ...
    
    gen_select = ...
    def gen_fake(self, field_name, fake):
        """ Generate a fake value for field with `field_name`.

        :param field_name: Name of field for generation.
        :param fake: Instance of :class:`~mixer.main.Fake`.

        :return : None or (name, value) for later use

        """
        ...
    
    def gen_value(self, field_name, field, fake=..., unique=...):
        """ Generate values from basic types.

        :return : (name, value) for later use

        """
        ...
    
    def get_fabric(self, field, field_name=..., fake=...):
        """ Get an objects fabric for field and cache it.

        :param field: Field for looking a fabric
        :param field_name: Name of field for generation
        :param fake: Generate fake data instead of random data.

        :return function:

        """
        ...
    
    def make_fabric(self, scheme, field_name=..., fake=..., kwargs=...):
        """ Make a fabric for scheme.

        :param field_class: Class for looking a fabric
        :param scheme: Scheme for generation
        :param fake: Generate fake data instead of random data.

        :return function:

        """
        ...
    
    def register(self, field_name, func, fake=...):
        """ Register function as fabric for the field.

        :param field_name: Name of field for generation
        :param func: Function for data generation
        :param fake: Generate fake data instead of random data.

        ::

            class Scheme:
                id = str

            def func():
                return 'ID'

            mixer = TypeMixer(Scheme)
            mixer.register('id', func)

            test = mixer.blend()
            test.id == 'id'

        """
        ...
    
    @staticmethod
    def is_unique(field):
        """ Return True is field's value should be a unique.

        :return bool:

        """
        ...
    
    @staticmethod
    def is_required(field):
        """ Return True is field's value should be defined.

        :return bool:

        """
        ...
    
    @staticmethod
    def get_default(field):
        """ Return a default value for the field if it exists.

        :return value:

        """
        ...
    
    @staticmethod
    def guard(*args, **kwargs):
        """ Look in storage.

        :returns: False

        """
        ...
    
    def reload(self, obj):
        """ Reload the object from storage. """
        ...
    


class ProxyMixer:
    """ A Mixer's proxy. Using for generate more than one object.

    ::

        mixer.cycle(5).blend(somemodel)

    """
    def __init__(self, mixer, count=..., guards=...) -> None:
        ...
    
    def blend(self, scheme, **values):
        """ Call :meth:`Mixer.blend` a few times. And stack results to list.

        :returns: A list of generated objects.

        """
        ...
    
    def __getattr__(self, name):
        ...
    


class _MetaMixer(type):
    FAKE = ...
    MIX = ...
    RANDOM = ...
    SELECT = ...
    SKIP = ...


class Mixer(_.with_metaclass(_MetaMixer)):
    """ This class is using for integration to an application.

    :param fake: (True) Generate fake data instead of random data.
    :param factory: (:class:`~mixer.main.GenFactory`) Fabric's factory

    ::

        class SomeScheme:
            score = int
            name = str

        mixer = Mixer()
        instance = mixer.blend(SomeScheme)
        print instance.name  # Some like: 'Mike Douglass'

        mixer = Mixer(fake=False)
        instance = mixer.blend(SomeScheme)
        print instance.name  # Some like: 'AKJfdjh3'

    """
    type_mixer_cls = ...
    def __init__(self, fake=..., factory=..., loglevel=..., silence=..., locale=..., **params) -> None:
        """Initialize the Mixer instance.

        :param fake: (True) Generate fake data instead of random data.
        :param loglevel: ('WARN') Set level for logging
        :param silence: (False) Don't raise any errors if creation was falsed
        :param factory: (:class:`~mixer.main.GenFactory`) A class for
                          generation values for types

        """
        ...
    
    def __getattr__(self, name):
        ...
    
    @property
    def SKIP(self, *args, **kwargs):
        """ Do not generate a field.

        ::
            # Don't generate field 'somefield'
            mixer.blend(SomeScheme, somefield=mixer.skip)

        :returns: SKIP_VALUE

        """
        ...
    
    @property
    def FAKE(self, *args, **kwargs):
        """ Force generation of fake values. See :class:`~mixer.main.Fake`.

        :returns: Fake object

        """
        ...
    
    @property
    def RANDOM(self, *args, **kwargs):
        """ Force generation of random values. See :class:`~mixer.main.Random`.

        :returns: Random object

        """
        ...
    
    @property
    def SELECT(self, *args, **kwargs):
        """ Select data from a storage. See :class:`~mixer.main.Select`.

        :returns: Select object

        """
        ...
    
    @property
    def MIX(self, *args, **kwargs):
        """ Point to mixed object from future. See :class:`~mixer.main.Mix`.

        :returns: Mix object

        """
        ...
    
    def __init_params__(self, locale=..., **params):
        ...
    
    def __repr__(self):
        ...
    
    def blend(self, scheme, **values):
        """Generate instance of `scheme`.

        :param scheme: Scheme class for generation or string with class path.
        :param values: Keyword params with predefined values
        :return value: A generated instance

        ::

            mixer = Mixer()

            mixer.blend(SomeScheme, active=True)
            print scheme.active  # True

            mixer.blend('module.SomeScheme', active=True)
            print scheme.active  # True

        """
        ...
    
    def get_typemixer(self, scheme):
        """ Return a cached typemixer instance.

        :return TypeMixer:

        """
        ...
    
    @staticmethod
    def postprocess(target):
        """ Run the code after generation.

        :return target:

        """
        ...
    
    @staticmethod
    def sequence(*args):
        """ Create a sequence for predefined values.

        It makes a infinity loop with given function where does increment the
        counter on each iteration.

        :param args: If method get more one arguments, them make generator
                      from arguments (loop on arguments). If that get one
                      argument and this equal a function, method makes
                      a generator from them. If argument is equal string it
                      should be using as format string.

                      By default function is equal 'lambda x: x'.

        :returns: A generator

        Mixer can uses a generators.
        ::

            gen = (name for name in ['test0', 'test1', 'test2'])
            for counter in range(3):
                mixer.blend(Scheme, name=gen)

        Mixer.sequence is a helper for create generators more easy.

        Generate values from sequence:
        ::

            for _ in range(3):
                mixer.blend(Scheme, name=mixer.sequence('john', 'mike'))


        Make a generator from function:
        ::

            for counter in range(3):
                mixer.blend(Scheme, name=mixer.sequence(
                    lambda c: 'test%s' % c
                ))


        Short format is a python formating string
        ::

            for counter in range(3):
                mixer.blend(Scheme, name=mixer.sequence('test{0}'))

        """
        ...
    
    def cycle(self, count=...):
        """ Generate a few objects. The syntastic sugar for cycles.

        :param count: List of objects or integer.
        :returns: ProxyMixer

        ::

            users = mixer.cycle(5).blend('somemodule.User')

            profiles = mixer.cycle(5).blend(
                'somemodule.Profile', user=(user for user in users)

            apples = mixer.cycle(10).blend(
                Apple, title=mixer.sequence('apple_{0}')

        """
        ...
    
    def middleware(self, scheme):
        """ Middleware decorator.

        You could add the middleware layers to generation process: ::

            from mixer.backend.django import mixer

            # Register middleware to model
            @mixer.middleware('auth.user')
            def encrypt_password(user):
                user.set_password('test')
                return user


        You can add several middlewares.
        Each middleware should get one argument (generated value) and return
        them.

        """
        ...
    
    def unregister_middleware(self, scheme, middleware):
        """Remove middleware from scheme
        """
        ...
    
    def register(self, scheme, **params):
        """ Manualy register a function as value's generator for class.field.

        :param scheme: Scheme for generation (class or class path)
        :param params: Kwargs with generator's definitions (field_name=field_generator)

        ::

            class Scheme:
                id = str
                title = str

            def func():
                return 'ID'

            mixer.register(
                Scheme,
                id=func,
                title='Always same',
            )

            test = mixer.blend(Scheme)
            test.id == 'ID'
            test.title == 'Always same'

        """
        ...
    
    @contextmanager
    def ctx(self, **params):
        """ Redifine params for current mixer as context.

        ::

            with mixer.ctx(commit=False):
                hole = mixer.blend(Hole)
                self.assertTrue(hole)
                self.assertFalse(Hole.objects.count())

        """
        ...
    
    def reload(self, *objs):
        """ Reload the objects from storage. """
        ...
    
    def guard(self, *args, **kwargs):
        """ Abstract method. In some backends used for prevent object creation.

        :returns: A Proxy to mixer

        """
        ...
    


mixer = Mixer()
